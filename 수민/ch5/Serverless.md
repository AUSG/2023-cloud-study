기본적으로 서버리스 기술은 클라우드 공급자가 모든 관리를와 가용성과 용량 등을 책임지기 때문에 기본 인프라 및 플랫폼 관리에 대한 걱정을 안해도 됨. 즉 인프라적인 부분은 aws같은 클라우드 공급자가 알아서 해주기 때문에 사용자는 코드만 짜면 됨.

# 5.1 ALB에서 람다 함수를 호출하도록 구성
``` bash
시작하기 앞서 퍼블릿 서브넷 두개가 필요해서 vpc를 생성하고 subnet을 인터넷 게이트웨이에 연결
그 다음 ec2 탭에 가서 ALB를 생성했고 대상 그룹(필수)도 같이 생성하고 람다 함수를 추후에 넣는 옵션을 선택
-> http 요청에 응답할 람다 함수를 만들어준 다음 해당 람다 함수를 대상 그룹으로 등록 -> alb 리스너의 규칙에 /function 경로에 대해 내가 만든 람다 함수로 가도록 설정!!
근데 연결이 안돼서 찾아봤더니 람다함수와 alb는 vpc에 같이 존재해야해서 람다함수 역할엘 vpc 정책을 추가해주고 alb에 등록했던 vpc를 람다 함수에 연결 후 테스트 했더니 응답이 왔습니다!!(보안그룹도 80번 포트에 대해 받을 수 있도록 인바운드 규칙을 조금 수정했어여)
```
alb를 이용해서 특정 경로에 대해 람다 함수를 호출할 수 있고 이렇게 하다보면 단일 로드 밸런서에서 여러 경로와 대상을 가질 수 있겓 됨.(람다 말고도 ec2나 컨테이너로도 대상 선정이 가능)

# 5.2 람다 계층을 사용한 라이브러리 패키징
```
람다 계층은 라이브러리 나 기타 종속성을 패키징할 수 있도록 제공. .zip파일로 계층을 생성할 수 있고 s3에 저장된 파일도 가능. 
즉, 기본적으로 제공해주는 python 런타임 이외에 라이브러리를 추가하거나 사용자 정의 런타임을 사용할 수 있음.
해당 예제에서는 requests 모듈을 해당 람다 함수에 계층으로 추가해주는 과정! 이때 zip파일로 계층을 생성
```

# 5.3 람다 함수 스케쥴링
```
aws EventBridge 서비스를  통해 일정을 만들 수 있음
일정은 일회성인지 반복인지 정할 수 있고 반복 일정의 경우엔 cron기반과 rate기반이 있음.
대상 선택 api 경우엔 여러개가 있는데 container도 있고 lambda도 존재하고 다양하게 존재.
재시도 횟수랑 이런것도 추가적으로 정할 수 있고 DLQ라고 대상에 성공적으로 전달되지 못했을 경우 사용하는 SQS 대기열!
추가적으로 권한에는 역할 만들어주면 끝! 이후에는 람다의 로그를 확인하기 위해 람다함수의 모니터링 탭에서 cloud wathc 로그 보는 탭을 선택해서 확인!!
```

# 5.4 람다 함수에서 EFS 파일 시스템 사용
``` bash
서버리스 컴퓨팅과 서버리스 영구 저장소를 사용하면 컴퓨팅 및 스토리지 운영 오버헤드를 크게 줄일 수 있음.
일단 먼저 vpc 셋팅을 진행하고 efs를 하나 만들고 vpc를 내가 만든 것과 연결함.
액세스 포인트를 하나 생성해주고 nfs의 보안그룹은 vpc의 서브넷 보안그룹을 수정하면 되고 람다 함수의 보안 그룹 tcp 2049포트에 대한 허용을 해줌.
람다 함수의 경우엔 vpc에 대한 권한을 추가해줌. 그 다음 람다 함수의 vpc를 편집하고 그다음 파일 시스템을 추가해주면 끝!
python 코드를 test해주면 잘 연결됐는지 확인될 수 있음!
```

# 5.5 AWS Signer를 사용한 람다 코드의 무결성 확인
```
코드 서명은 관리자가 Lambda 함수에서 신뢰할 수 있는 게시자가 제공한 서명된 코드 패키지만 실행하고 서명 이후에는 코드가 변경되지 않도록 강제할 수 있도록 지원하는 신뢰 및 무결성 제어
-> lambda에 신뢰할 수 있는 코드만 배포되도록 할 수 있음을 의미.
Lambda용 코드 서명은 AWS Signer를 활용. 먼저 서명 프로필을 만들고 그 다음 CSC(코드 서명 구성)을 생성하게 되는데 관리자는 CSC를 사용하여 함수에 대한 코드 서명 정책을 설정할 수 있고 개발자는 함수에 코드를 배포할 수 있음.
그 다음 lambda 함수에 가서 코드 서명을 활성화하고 만들었던 CSC를 선택하고 저장해주면 됨. 다음에는 AWS Signer 서비스에 가서 서명 작업을 해주면 되는데 이때 서명할 코드 패키지 zip파일의 s3 위치를 지정해야하고 서명된 코드 패키지를 업로드할 s3 위치도 지정해줘야함. 서명 작업은 코드 패키지에 대한 서명을 생성하고 서명된 코드 패키지를 지정된 대상 경로로 배치하는 비동기식 프로세스 과정!-> 이제 서명작업이 끝나면 s3에 서명된 zip 패키지가 업로드되어 있는 것을 확인할 수 있음.
```

# 5.6 컨테이너 이미지를 람다에 배포
```
이번 챕터는 되게 간단한 구성!
먼저 ecr하나를 만들어준다음에 기존의 도커에 login을 한 뒤 lambda에 배포할 py파일 하나를 dockerfile을 이용해서 이미지를 만들고 tag를 달아서 ecr에 올림
그 다음 lambda에서는 함수를 새로 작성할 수도 있고 블루프린트를 사용하거나 컨테이너 이미지를 사용해서 람다 함수를 생성할 수 있음. 컨테이너 이미지를 참조할 때는 유효한 Amazon ECR 이미지 URI가 필요함. 추가적으로 컨테이너 이미지를 사용해서 함수를 생성할때는 --runtime 이나 handler 매개변수를 사용해서 cli로 만들 수 없음. 컨테이너 이미지를 이용하면 기존에 사용하던 빌드, 테스트, 패키지, 배포 ㄱ파이프라인을 사용할 수 있음. 그리고 함수에서 이미지를 사용하기 위해선 이미지가 들어있는 ECR과 동일한 계정에 있어야함.

그러면 fargate도 있는데 굳이 컨테이너 이미지를 사용해서 lambda를 사용하는 이유는 뭘까?

lambda 같은 경우엔
- 이벤트에 대한 작업을 트리거해야하는 경우 사용하게 됨
- 배포 패키지 크기가 작고 실행 시간이 15분 이하인 경우
- 비용적인 문제가 있을 경우

fargate 같은 경우엔
- 15분을 넘는 작업이 필요한 경우
- 컨테이너 간 통신이 필요할 때
- 실행 환경을 자유롭게 구성해야할 경우

비용적인 문제로 봤을때 만약 람다의 콜드 타임(15분) 아래이고 이벤트 기반으로 트리거를 해야하는 경우라면 람다 함수를 적용하는게 효율적이고 그렇지 않고 더 많은 시간의 작업이 걸리고 컨테이너 간 통신이 필요한 경우엔 fargate를 사용하는게 효율적.
```

# 5.7 S3의 CSV 데이터를 람다를 사용해 DynamoDB로 로드
```
이번 챕터는 s3에 적재되어있는 객체를 람다 함수를 이용해 DynamoDB로 로드하는 챕터임.
람다를 써서 이벤트가 발생할때만 동작 시킬 수 있고(데이터가 s3에 업로드되었을 때) 이는 운영 오버헤드를 최소화하고 데이터베이스 지속성을 가져갈 수 있음.
먼저 기본적으로 s3 버킷과 람다 함수가 필요하고 람다 함수에 적용될 iam에는 s3를 read할 수 있는 권한과 dynamoDB에 full access할 권한이 필요하고 람다 함수를 실행시킬 권한 또한 필요!
그리고 추후에 이제 s3에 객체가 업로드 되었을 때 람다하수를 트리거로 발생시키기 위해 트리거에 s3 버킷을 추가해주면 되고 접두사나 접미사 같은 것도 따로 지정해서 할 수 있음.
이러한 이벤트 기반 아키텍쳐는 비용적이면에서 효율적!
```

# 5.8 프로비저닝된 동시성을 사용해 람다 시작 시간 단축
```
람다 함수의 경우 함수 코드의 실행 환경은 요청 시 프로비저닝되므로 약간의 시간이 걸리게 되는데 이걸 콜드 스타트라고 부름. 하지만 매번 그런게 아니고 람다는 일정 기간 동안 실행 환경을 웜이라고 부르는 상태를 유지하고 만약 함수가 그 상태에서 다시 호출되면 프로비저닝 없이 바로 코드를 실행할 수 있음. 즉, 웜 상태의 경우엔 콜드 스타트가 거의 없음. 함수가 많은 동시성을 달성해야 하는 경우엔 콜드 스타트를 피하기 위해서 동시성 기능을 사용해서 복제한 실행 환경을 웜 상태로 유지할 수 있음. 동시성에 대한 구성은 람다의 -> 구성 -> 동시성에서 설정이 가능
```

# 5.9 람다에서 VPC 내의 리소스 접근
```
람다 함수를 사용해서 vpc 내의 ElasticCache에 접근할 수도 있음. 일단 접근하기 위해서는 둘다 모두 같은 vpc에 존재해야함. 그리고 ElasticCache 클러스터의 종류는 Redis나 Memcached가 존재하고 처음에 생성할 때 서브넷 그룹이 필요. 람다는 vpc에 대한 access 정책이 추가적으로 필요하고 ElasticCache의 경우엔 vpc에 네트워크 인터페이스를 가진 컴퓨팅 노드가 필요.(즉, vpc가 네트워크 인터페이스를 프로비저닝해야함).
그럼 언제 memcached를 사용하고 redis를 사용하는지?

memcached의 경우
- 작고 정적인 데이터를 캐싱하는 경우
- 멀티 쓰레드가 처리하는 경우

redis의 경우(single thread)
- 문자열, 해시, 목록, 세트, 정렬된 세트 및 비트맵과 같은 복잡한 유형의 데이터를 다룰때
- key-value 저장소의 속성을 원할 경우
```